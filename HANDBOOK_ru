

справочник tuna                 последняя ревизия 31.01.2026


Содержание
------------------------------------------------------------

    Предупреждение                                    32
    Вступление                                        42
    Установка                                         52
    Лицензия                                          70
    Философия                                         82

    Классы                                            98
      Скрипт                                       101
      Объект                                       126
      Мир                                          163

    Рантайм                                          195
      Инициализация и Деструкция                   198
      Циклы                                        204

    Основы                                           223
      Снапшоты                                     226
      Префабы                                      257
      Связи                                        271

    Реализация                                       291


Предупреждение
------------------------------------------------------------

    На данный момент, tuna находиться на стадии открытого
тестирования, по этому архитектура и справочник могут быть
подвержены значительным правкам.  tuna не стабилен и не
готов к использованию в продакшене, но тестировать что-то
новое всегда весело!


Вступление
------------------------------------------------------------

    tuna — относительно маленький header-only фреймворк для
разработки игр на C++.  Единственное, что он навязывает —
это архитектуру.  Вы можете сами выбрать рендеринг, систему
звуков, библиотеку ввода и менеджер ресурсов.  tuna
реализовывает лишь объектную модель игрового мира.


Установка
------------------------------------------------------------

    tuna можно удобно установить двумя способами.

    1.  Скачайте файл tuna.hh и поместите его в include path
        Вашего проекта.

    2.  Клонируйте или сделайте субмодулем этот репозиторий.
        Добавьте его каталог как ещё один include path
        Вашего проекта.  Установка этим способом подходит
        лучше всего, если Вам нужно иметь самую последнюю
        версию tuna.

    tuna использует нововведения C++20 и не сможет
скомпилироваться на стандарте C++17 и ниже.


Лицензия
------------------------------------------------------------

    tuna лицензирован под MPL 2.0 — это свободная лицензия
на программное обеспечение, издаваемая Mozilla.  Она
относиться к категории слабых копилефт-лицензий.  Это
означает, что Вы можете использовать код лицензированный под
MPL 2.0 в проектах с отличной лицензией или в проектах с
закрытым исходным кодом.  Но любые изменения должны быть
открыты.


Философия
------------------------------------------------------------

    Важно уточнить, что просто установив tuna в Ваш проект —
Вы не получите даже пустой проект.  Это связано с тем, что
навязывать слишком много всего в одной библиотеке, часто
приводит к тому, что кому-то может не угодить определённая
её часть.  Но из за того, что библиотека цельная, заменить
эту часть будет довольно сложно.

    tuna оставляет Вам пространство для манёвра, за что
приходиться платить временем на реализацию некоторых вещей
вручную.  В прочем, в этом справочнике есть раздел
Реализация, который Вам с этим поможет.


Классы
------------------------------------------------------------

    Скрипт (tuna::Script):
            Это то что наделяет объекты поведением.  Здесь
        Вы пишете игровую логику.  Наследуйте Ваш скрипт от
        этого класса чтобы иметь возможность наделить им
        объект.

            Указатель на родительский объект, который
        присваивается автоматически при наделении скриптом
        объекта:

std::weak_ptr<Object> parent

        Стандартный деструктор:

virtual ~Script(void)

            Методы игрового цикла (Описание находиться в
        разделе Рантайм, Циклы):

virtual void loop(const float DELTA_TIME)
virtual void step(const float FIXED_DELTA_TIME)
virtual void post(const float DELTA_TIME)
virtual void drew(const float DELTA_TIME)


    Объект (tuna::Object):
            Просто контейнер скриптов.

            Уникальный ID объекта, присваиваемое ему при
        создании:

const ObjectID id

            Сам контейнер скриптов:

std::vector<std::shared_ptr<Script>> scripts

            Стандартный конструктор:

Object(ObjectID iid) : id(iid)

            Найти скрипт на объекте и получить итератор на
        него:

template<typename T> auto find(void)

            Найти скрипт на объекте и получить ссылку на
        него:

template<typename T> std::weak_ptr<T> seek(void)

            Наделить объект скриптом и передать аргументы в
        конструктор.  Если скрипт уже был на объекте,
        аргументы конструктора проигнорируются:

template<typename T, typename... ARGS> std::weak_ptr<T> grant(ARGS&&... iargs)

            Удалить скрипт с объекта:

template<typename T> bool take(void)


    Мир (tuna::World):
            Мир является контейнером объектов, а также
        менеджером игрового цикла.  Имеет метод dispatch
        который используется для вызова методов игрового
        цикла на всех живых скриптах в мире.

            Сам контейнер объектов:

std::unordered_map<ObjectID, std::shared_ptr<Object>> objects

            Очистить мир полностью:

void clean(void)

            Создать объект в этом мире:

std::weak_ptr<Object> create(void)

            Найти объект по уникальному ID:

std::weak_ptr<Object> seek(ObjectID iid)

            Поместить объект в очередь на удаление.  Объект
        удалиться при следующем dispatch:

bool kill(ObjectID iid)

            Вызвать метод на всех живых скриптах в мире:

template<auto METHOD, typename... ARGS> void dispatch(ARGS&&... iargs)


Рантайм
------------------------------------------------------------

    Инициализация и Деструкция:
            В tuna у скриптов нет методов вроде Start или
        OnDestroyed.  Вместо них используйте конструкторы и
        деструкторы.


    Циклы:
            В tuna есть несколько разновидностей циклов.
        Все они являются методами tuna::Script.  Ниже их
        описания в том порядке, в котором они должны быть
        вызваны:

            tuna::Script::step — вызывается с фиксированным
        интервалом.  Принимает const float FIXED_DELTA_TIME.

            tuna::Script::loop — вызывается перед каждой
        отрисовкой кадра.  Принимает const float DELTA_TIME.

            tuna::Script::post — вызывается сразу после
        tuna::Script::loop.  Принимает const float DELTA_TIME.

            tuna::Script::drew — вызывается после отрисовки
        кадра.  Принимает const float DELTA_TIME.


Основы
------------------------------------------------------------

    Снапшоты:
            В tuna нет сцен в привычном понимании игровых
        движков.  Вместо них есть снапшоты.  Снапшоты — это
        просто метод, который вызывает методы создания
        объектов и удаления объектов.

            Обычный способ сделать сцену:

TUNA_NEW_SNAPSHOT(main) {
    world.clean();
    ...
    return;
}

            Вызов world.clean нужен чтобы при повторной
        загрузке снапшота — мир перезаписался, повторяя
        поведение переключения сцены.

            Можно обойтись и без очистки мира внутри самого
        снапшота, если Вы хотите реализовать менеджер сцен
        отдельно.

            Загрузить можно так:

TUNA_LOAD_SNAPSHOT(main, world);

            А получить имя метода можно так:

TUNA_SNAPSHOT(main)


    Префабы:
            Их в tuna тоже нет.  Но учитывая прошлый опыт со
        снапшотами, можно снова воспользоваться
        импровизацией:

void player_prefab(std::weak_ptr<tuna::Object> obj, Some controller) {
    auto object = obj.lock();
    if(!object) return;
    object->grant<PlayerMovement>(controller);
    ...
    return;
}


    Связи:
            В tuna нет поиска по скриптам или по имени
        объекта, так-что найти нужный скрипт будет сложно.
        Но искать и не надо.  Так как мы уже создаём и
        храним все скрипты и объекты в снапшотах, ссылки
        можно передавать прямо из них:

TUNA_NEW_SNAPSHOT(main) {
    world.clean();

    // Player
    if(auto obj = world.create().lock()) {
        auto transform = obj->grant<Transform>();
        auto playermovement = obj->grant<PlayerMovement>(transform);
    }

    return;
}


Реализация
------------------------------------------------------------

    Предположим, что Вы уже установили tuna и Вашу любимую
библиотеку рендеринга.  Для примера, тут будет абстрактный
"draw".  Объявите функцию main — она будет главной.

int main(void) {
    return 0;
}

    Далее, инициализируйте окно и подготовьте цикл
отрисовки.

int main(void) {
    draw::create_window(400, 400, "Tuna!");

    while(!draw::window_should_close()) {
        draw::begin_drawing();
            draw::fill(draw::color::sky_blue);
        draw::end_drawing();
    }

    draw::destroy_window();
    return 0;
}

    Теперь можно перейти к интеграции tuna.  Создаём мир и
вставляем базовые глобальные вызовы.  Также создаём базовый
снапшот и загружаем его.

TUNA_NEW_SNAPSHOT(Main) {
    world.clean();
    return;
}

int main(void) {
    draw::create_window(400, 400, "Tuna!");

    float delta_time = 0.0f;

    tuna::World world;
    TUNA_LOAD_SNAPSHOT(Main, world);

    while(!draw::window_should_close()) {
        world.dispatch<&tuna::Script::loop>(delta_time);
        world.dispatch<&tuna::Script::post>(delta_time);

        draw::begin_drawing();
            draw::fill(draw::color::sky_blue);
        draw::end_drawing();

        delta_time = draw::get_frame_time();

        world.dispatch<&tuna::Script::drew>(delta_time);
    }

    world.clean();
    draw::destroy_window();
    return 0;
}

    Для полноты картины реализуем вызов с фиксированным
шагом.

TUNA_NEW_SNAPSHOT(Main) {
    world.clean();
    return;
}

int main(void) {
    draw::create_window(400, 400, "Tuna!");

    float delta_time = 0.0f;
    constexpr float fixed_delta_time = 1.0 / 50.0f;
    float time_accumulator = 0;

    tuna::World world;
    TUNA_LOAD_SNAPSHOT(Main, world);

    while(!draw::window_should_close()) {
        while(time_accumulator >= fixed_delta_time) {
            world.dispatch<&tuna::Script::step>(fixed_delta_time);
            time_accumulator -= fixed_delta_time;
        }

        world.dispatch<&tuna::Script::loop>(delta_time);
        world.dispatch<&tuna::Script::post>(delta_time);

        draw::begin_drawing();
            draw::fill(draw::color::sky_blue);
        draw::end_drawing();

        delta_time = draw::get_frame_time();
        time_accumulator += delta_time;

        world.dispatch<&tuna::Script::drew>(delta_time);
    }

    world.clean();
    draw::destroy_window();
    return 0;
}

    Готово!  Это всё что нужно для начала работы с tuna.

